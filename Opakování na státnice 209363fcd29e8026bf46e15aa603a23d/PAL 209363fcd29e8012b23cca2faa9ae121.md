# PAL

# Asymptotick√° notace

Mƒõjme fci $f(n)$ a funkci $g(n)$. ≈ò√≠k√°me, ≈æe:

- $f(n) \in \Omega(g(n))$, pokud $(\exist c > 0)(\exist n_0) (\forall n > n_0) : c \cdot g(n) \leq f(n)$
- $f(n) \in \Omicron(g(n))$, pokud $(\exist c > 0)(\exist n_0) (\forall n > n_0) : f(n) \leq c \cdot g(n)$
- $f(n) \in \Theta(g(n))$, pokud $(\exist c_1 > 0, \exist c_2 > 0)(\exist n_0) (\forall n > n_0) : c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n)$

# Grafy

**Node degree** (neboli *stupe≈à uzl≈Ø*) je poƒçet hran, kter√© do nebo z dan√©ho vrcholu vedou. Pokud se jedn√° o orientovan√Ω graf rozli≈°ujeme tzv *indegree* a *outdegree**,*** kde *indegree* je mno≈æina v≈°ech vstupn√≠ch hran a *outdegree* je mno≈æinou v≈°ech hran v√Ωstupn√≠ch.

Graph **path** (neboli *cesta*), je sekvence hran a vrchol≈Ø, kde se ≈æ√°dn√© 2 vrcholy neopakuj√≠, tedy ani hrany.

- **tah** je posloupnost, kde se mohou opakovat vrcholy ale ne hrany
- **sled** je posloupnost, kde se mohou opakovat jak hrany, tak vrcholy

Graph **circuit** je tah, kter√° je uzva≈ôen√°, tedy $v_t = v_0$, kde $v_t$ je koncov√Ω vrchol cesty a $v_0$ je poƒç√°teƒçn√° vrchol cesty mohou se v n√≠ opakovat vrcholy.

Graph **cycle** je cesta, kter√° je uzav≈ôen√° stejnƒõ jako *circuit*. Oproti nƒõmu se ale nesm√≠ opakovat ani hrana ani vrchol.

## Reprezentace graf≈Ø

### Adjacency Matrix

Nech≈• $G=(V,E)$ je graf s $n$ vrcholy. Znaƒçme si je $v_1, ..., v_n$. Adjacency matrix of graph $G$ je ƒçtevrcov√° matice $A_G=(a_{i,j})^n_{i,j=1}$ definovavn√©, jako $a_{i,j} == 1 \text{ for }\{v_i,v_j\} \in E \text{ otherwise } 0$.

Jednodu≈°e, pokud jsou hrany spojeny, v dan√©m smƒõru, je tam jedniƒçka, pokud spojny nejsou, je tam nula.

![image.png](PAL%20209363fcd29e8012b23cca2faa9ae121/image.png)

### Laplacian Matrix

Spojen√≠ adjecency matrix s informaci o node degree.

Jsou-li hrany spojen√©, zapi≈° `-1`, je-li v matici hrana sama se sebou, zapi≈°e jej√≠ `degree` (tedy poƒçet hran), pokud nen√≠ s dan√Ωm vrcholme spojen√°, zapi≈° `0`.

![image.png](PAL%20209363fcd29e8012b23cca2faa9ae121/image%201.png)

### Incidence Matrix

Matice je tvo≈ôena $n\times m$, kde $|V|=n$ a $|E| = m$ a hodnotami $\{-1, 0, 1\}$. Hodnota v poli je rovna:

- $-1$ pokud z  dan√©ho vrcholu dan√° hrana odv√°d√≠ edge
- $0$ pokud v dan√©m vrcholu hrana neexistuje
- $1$ pokud do dan√©ho vrcholu dan√° hrana vede edge

![image.png](PAL%20209363fcd29e8012b23cca2faa9ae121/image%202.png)

### Adjacency List

Jinak se t√©to grafov√© reprezetnaci tak√© ≈ô√≠k√° *list of neighborurs* neboli listy soused≈Ø. Funguje tak, ≈æe pro ka≈æd√Ω vrchol dr≈æ√≠ list pointer≈Ø na sousedn√≠ vrcholy.

![image.png](PAL%20209363fcd29e8012b23cca2faa9ae121/image%203.png)

## Srovn√°n√≠ jednotliv√Ωch reprezentac√≠

|  | Adjecency Matrix | Laplacian Matrix | Incidence Matrix | Adjacency List |
| --- | --- | --- | --- | --- |
| Storage | $\Omicron(|V|^2)$ | $\Omicron(|V|^2)$ | $\Omicron(|V| \cdot |E|)$ | $\Omicron(|V|+|E|)$ |
| Add vertex | $\Omicron(|V|^2)$ | $\Omicron(|V|^2)$ | $\Omicron(|V| \cdot |E|)$ | $\Omicron(|V|)$ |
| Add edge | $\Omicron(1)$ | $\Omicron(1)$ | $\Omicron(|V| \cdot |E|)$ | $\Omicron(1)$ |
| Remove vertex | $\Omicron(|V|^2)$ | $\Omicron(|V|^2)$ | $\Omicron(|V| \cdot |E|)$ | $\Omicron(|E|)$ |
| Remove edge | $\Omicron(1)$ | $\Omicron(1)$ | $\Omicron(|V| \cdot |E|)$ | $\Omicron(|V|)$ |

# Minimum Spanning Tree (Minim√°ln√≠ kostra grafu)

**Minimum Spanning Tree** neboli *Minim√°ln√≠ kostra grafu* $G=(V,E)$ **je mno≈æina vrchol≈Ø $V$ a hran $E'$ z grafu $G$, kter√© zajist√≠, ≈æe je ka≈æd√Ω vrchol grafu $G$ spojen se v≈°emi ostatn√≠mi vrcholy a to s minim√°ln√≠ cenou. P≈ôiƒçem≈æ minim√°ln√≠ cena je definovan√° jakou souƒçet vah hran grafu, kter√© jsou pou≈æity, tedy souƒçet hran z mno≈æiny $c(E')$ mus√≠ b√Ωt minim√°ln√≠.

## Algoritmy

### Jarn√≠k-Prim

Algoritmus funguje podobnƒõ jako Dijkstra, jen je terminov√°n, jakmile nav≈°t√≠v√≠ v≈°echny vrcholy. Funguje tak, ≈æe:

1. Zaƒçne na jak√©mkoliv vrcholu. Ten oznaƒç√≠ jako `visited`  a p≈ôid√° do prioritn√≠ho seznamu v≈°echny hrany, kter√© z p≈ôidan√©ho vrcholu vedou.
2. P≈ôejde do vrcholu, kter√Ω nen√≠ ve stavu `visisted` a opakuje krok ƒç. 1.
3. Konƒç√≠ jakmile jsou p≈ôid√°ny v≈°echny vrcholy grafu.

ƒåasov√° slo≈æitost z√°le≈æ√≠ na vyu≈æit√Ωch struktur√°ch. Obecnƒõ je ale ƒçasov√° slo≈æitost $\Omicron(n\cdot m)$, kde $n=|V(G)|$ a $m=|E(G)|$. 

### Bor≈Øvka

**üí° Zaj√≠mavost:** Jedn√° se o nejstar≈°√≠ algoritmus pro MST.

Funguje tak, ≈æe postupnƒõ spojuje komponenty souvislosti. Na zaƒç√°tku je komponenta s√°m ka≈æd√Ω vrchol. V ka≈æd√© f√°zi vyb√≠r√° v≈ædy nejlevnƒõj≈°√≠ hranu, kter√© smƒõ≈ôuje do jin√© komponenty souvislosti.

![](https://upload.wikimedia.org/wikipedia/commons/2/2e/Boruvka%27s_algorithm_%28Sollin%27s_algorithm%29_Anim.gif)

### Kruskal

Se≈ôad√≠ hrany od nejmen≈°√≠ po nejvy≈°≈°√≠. N√°slednƒõ hranu p≈ôid√°, pokud jej√≠m p≈ôid√°n√≠m nevznikne cyklick√Ω graf.

![](https://upload.wikimedia.org/wikipedia/commons/b/bb/KruskalDemo.gif)

# Strongly Connected Components

≈ò√≠k√°me, ≈æe je komponenta silnƒõ souvisl√°, pokud plat√≠, ≈æe se mohu dostat z ka≈æd√©ho vrcholu do jak√©hokoliv jin√©ho.

![image.png](PAL%20209363fcd29e8012b23cca2faa9ae121/image%204.png)

## Kosarju-Shariri

K nalezen√≠ takov√Ωchto komponent, se vyu≈æ√≠v√° tohoto algoritmu.

Funguje tak, ≈æe:

1. provede DFS p≈ôi zav√≠r√°n√≠ p≈ôid√°v√° vrcholy do z√°sobn√≠ku
2. n√°slednƒõ prohod√≠ orientaci v≈°ech stran a proch√°z√≠ ze z√°sobn√≠ku (tj. od poslednƒõ nav≈°t√≠ven√©ho vrcholu)
3. t√≠mto n√°m vzniknou silnƒõ souvisl√© komponenty

### Tarjan‚Äôs Algorithm

Vyu≈æ√≠v√° pouze jedno DFS, je tedy efektvnƒõj≈°√≠ ne≈æ Kosarju-Shariri a nutnosti obracet graf.

## Eulerov≈Ø tah

Mƒõjme graf $G$ a chtƒõjme vytvo≈ôit trail (vrcholu se mohou opakovat, hrany ne), tak, aby byly v≈°echny vrcholy $V(G)$ nav≈°t√≠veny pr√°vƒõ jednou.

Plat√≠, ≈æe graf je eulerovsk√Ω, je-li souvisl√Ω a ka≈æd√Ω jeho vrchol m√° sud√Ω stupe≈à (sud√Ω poƒçet hran). ƒåi se tak√© d√° ≈ô√≠ci, ≈æe je Eulerovsk√Ω, m√°-li stejn√Ω poƒçet hran vstupn√≠ch jako v√Ωstupn√≠ch.

### Hamiltonsk√Ω cesta

Obdobn√Ω probl√©m jako eluler≈Øv, ov≈°em zde se nesm√≠ vyu≈æ√≠t ≈æ√°dn√° hrana ani vrchol v√≠cekr√°t. Aplikac√≠ je √∫loha TSP.

# Union find problem

Nƒõkdy zn√°m√Ω tak√© jako Disjoint Set Union (DSU) je datov√° struktura, kter√° ≈ôe≈°√≠ probl√©m spr√°vy mno≈æin a umo≈æ≈àuje prov√°dƒõt 2 operace:

- `find(x)` - zjisti, do kter√© mno≈æiny pat≈ô√≠ prvek `x`
- `union(x,y)` - spoj mno≈æiny, ve kter√Ωch jsou prvky `x` a `y`

# Graph Isomorphism

Prov√°dƒõt tzv. mapping a sna≈æit se namapovat vrcholy z grafy $G$ na vrcholy z grafu $G'$.

Pro zrychlen√≠ nen√≠ ≈°patn√© na zaƒç√°tku prov√©st nƒõjakou heruistiku, n√°p≈ô√≠klad stejn√Ω poƒçet vrchol≈Ø, stejn√Ω poƒçet hran, ‚Ä¶

Certifik√°ty je mo≈æn√© vyd√°vat pro stromy. 

Ot√°zka zn√≠, jak poznat, ≈æe jsou grafy stejn√©? ≈òe≈°en√≠m je vygenerov√°n√≠ certifik√°t≈Ø pro oba dva grafy. Pokud se shoduj√≠, pak jsou grafy stejn√©, pokud ne, tak nejsou isomorfn√≠.

![image.png](PAL%20209363fcd29e8012b23cca2faa9ae121/image%205.png)

# Enumaration & Generation

## Gray code

Jedn√° se o ƒç√≠selnou reprezentaci, jej√≠≈æ vlastnost√≠ je, ≈æe p≈ôi inkrementaci ƒç√≠sla o jedno ƒçi dekrementaci ƒç√≠sla o jedno se zmƒõn√≠ pouze jeden bit. Aplikace je nap≈ô√≠klad v mechanice. Pokud chceme k√≥dvat polohu rotoru, tak je pro n√°s v√Ωhodn√© mƒõnit pouze jeden bit a to ze dvou d≈Øvod≈Ø:

- zrychlen√≠ cel√©ho procesu (diskutabiln√≠, m√°me hardwarov√© ≈ôe≈°enou sƒç√≠taƒçku)
- hlavn√≠m d≈Øvodem je ale p≈ôesnost, zmƒõna jednoho bitu znep≈ôesn√≠ mƒõ≈ôen√≠ o mal√© mno≈æstv√≠, oproti klasick√© bin√°rn√≠ reprezentaci

## **Eratosthenovo s√≠to**

Algortimus pro nalezen√≠ prvoƒç√≠sel. Funguje tak, ≈æe po nalezen√≠ prvoƒç√≠sla vyjme v≈°echny jeho n√°sobky.

![](https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif)

## Linear congruential generator

Vyu≈æ√≠v√° polynom $x_{n+1}=(Ax_n+C) \text{ mod } M, n \geq 0$.

# Search Trees

**Trees:** Search trees - data structures, operations, and their complexities. Binary tree, AVL tree, red-black tree (RB-tree), B-tree and B+ tree, splay tree, k-d tree. Nearest neighbor searching in k-d trees. Skip list.

## ALV Tree

Jedn√° se o bin√°rn√° strom, kter√Ω se s√°m vyrovn√°v√°. Tj. zji≈°≈•uje, aby byl strom vyv√°≈æen√Ω. Vyu≈æ√≠v√° v√Ω≈°kovou rovnov√°hu a pro vyv√°≈æen√≠ vyu≈æ√≠v√° operace rotac√≠.

![](https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif)

## Red-Back Tree (RB-tree)

Jedn√° se o bin√°rn√≠ strom, kter√Ω se s√°m vyrovn√°v√° a vyu≈æ√≠v√° k tomu mechanismus barven√≠. Balancov√°n√≠ nen√≠ v≈ædy perfektn√≠

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ce/Red-black_tree_example_with_sockets.svg/1280px-Red-black_tree_example_with_sockets.svg.png)

## B+ Tree

Jedn√° se o *m-array tree*, tedy udr≈æuje v d√≠tƒõti v√≠ce hodnot.

B+ m√° data pouze v listech a vy≈°≈°√≠ nody obsahuj√≠ pouze informace pouze pro navigaci.

![](https://upload.wikimedia.org/wikipedia/commons/0/0c/B%2B-tree-remove-61.png)

## Splay Tree

Jedin√©, co dƒõl√°, tak m√° Splay operace. Tedy, to co jsi hledal, d√° do ko≈ôene. To zajist√≠, ≈æe m√°m pou≈æ√≠van√° data rychle p≈ô√≠stupn√°.

## K-D Tree

K-D znamen√° K dimensional tree. Jedn√° se o bin√°rn√≠ strom, kde ka≈æd√Ω node je k-dimensional point. vrcholu se ukl√°daj√≠ ne na *hypercube* ale na *hyperspace.*

Tato reprezentace je vhodn√° pro hled√°n√≠ nejbli≈°√≠ch soused≈Ø

## Skip List

Vyhled√°v√°n√≠ ve standatn√≠m linked listu je pomal√©, je t≈ôeba proj√≠t v≈°echny prvky $\Theta(n)$. My≈°lenka tohoto je, vytvo≈ôit v√≠ce √∫rovn√≠, aby bylo mo≈æn√© mezi daty p≈ôeskakovat a tak se rychleji p≈ôibl√≠≈æit k c√≠ly.

![](https://upload.wikimedia.org/wikipedia/commons/2/2c/Skip_list_add_element-en.gif)

| ALGORTIMUS | INSERT | DELETE | SEARCH | SPACE | Note |
| --- | --- | --- | --- | --- | --- |
| ALV tree | $\Omicron(\log n)$ | $\Omicron(\log n)$ | $\Omicron(\log n)$ | $\Omicron(n)$ | Pou≈æ√≠v√° rotace |
| RB tree | $\Omicron(\log n)$ | $\Omicron(\log n)$ | $\Omicron(\log n)$ | $\Omicron(n)$ | Pou≈æ√≠v√° barven√≠, nen√≠ tak p≈ôesn√Ω |
| B+ tree | $\Omicron(\log n)$ | $\Omicron(\log n)$ | $\Omicron(\log n)$ | $\Omicron(n)$ | Ukl√°d√° v√≠ce dat v node |
| K-D tree | $\Omicron(n)$ | $\Omicron(n)$ | $\Omicron(n)$ | $\Omicron(n)$ | Vyu≈æ√≠v√° v√≠ce dimenz√≠, nejbli≈æ≈°√≠ soused |
| Splay tree | $\Omicron(n)$ | $\Omicron(n)$ | $\Omicron(n)$ | $\Omicron(n)$ | Pou≈æ√≠van√° data jsou v rootu |
| Skip list | $\Theta(\log n)$ | $\Theta(\log n)$ | $\Theta(\log n)$ | $\Theta(n)$ | Linked list s mo≈ænost√≠ sk√°kat |